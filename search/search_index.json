{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Index Page","text":"<p>This site contains the project documentation for the <code>odooghost</code> project.</p>"},{"location":"index.html#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"index.html#project-overview","title":"Project Overview","text":"<p>OdooGhost is a powerful tool tailored for streamlining the development and deployment of Odoo instances. It offers an integrated solution that harnesses the power of Docker for orchestrating and managing these instances. With both a Command Line Interface (CLI) and an upcoming web interface, managing Odoo stacks has never been simpler.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Fine-grained Configuration: Customize each Odoo instance with configuration files, tailoring settings to fit your specific needs.</li> <li>Holistic Instance Management: With just a few commands, you can create, update, start, stop, and even delete Odoo instances straight from the CLI.</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"<p>To kickstart your OdooGhost journey: <code>pipx install odooghost</code>.  </p>"},{"location":"index.html#usage","title":"Usage","text":""},{"location":"index.html#initial-setup","title":"Initial Setup","text":"<p>Before diving deep into OdooGhost, ensure you set it up properly. Use the <code>setup</code> command and specify your working directory:</p> <pre><code>odooghost setup /you/working/dir\n</code></pre>"},{"location":"index.html#crafting-a-stack","title":"Crafting a Stack","text":"<p>To bring your Odoo instance to life, you first need to define its blueprint - the stack configuration file. Samples to guide your creation can be found here.</p> <pre><code>odooghost stack create you-stack-config.yaml\n</code></pre>"},{"location":"index.html#contribute","title":"Contribute","text":"<p>Have ideas or enhancements for OdooGhost? We'd love to see them! Create a Pull Request to join in the journey of making Odoo development smoother for everyone.</p>"},{"location":"index.html#license","title":"License","text":"<p>Licensed under the MIT License.</p>"},{"location":"explanation.html","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"how-to-guides.html","title":"How-To-Guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"reference.html","title":"Reference","text":""},{"location":"reference.html#odooghost.config","title":"<code>odooghost.config</code>","text":""},{"location":"reference.html#odooghost.config.ContextConfig","title":"<code>ContextConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Context config holds configuration file</p> Source code in <code>odooghost/config/app.py</code> <pre><code>class ContextConfig(BaseModel):\n    \"\"\"\n    Context config holds configuration file\n    \"\"\"\n\n    version: str\n    \"\"\"\n    OdooGhost version\n    \"\"\"\n    working_dir: Path\n    \"\"\"\n    Working directory\n    \"\"\"\n</code></pre>"},{"location":"reference.html#odooghost.config.ContextConfig.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>OdooGhost version</p>"},{"location":"reference.html#odooghost.config.ContextConfig.working_dir","title":"<code>working_dir: Path</code>  <code>instance-attribute</code>","text":"<p>Working directory</p>"},{"location":"reference.html#odooghost.config.OdooStackConfig","title":"<code>OdooStackConfig</code>","text":"<p>             Bases: <code>StackServiceConfig</code></p> <p>Odoo stack configuration</p> Source code in <code>odooghost/config/service.py</code> <pre><code>class OdooStackConfig(StackServiceConfig):\n    \"\"\"\n    Odoo stack configuration\n    \"\"\"\n\n    version: float\n    \"\"\"\n    Odoo version\n    \"\"\"\n    cmdline: t.Optional[str] = None\n    \"\"\"\n    Odoo-bin cmdline\n    \"\"\"\n    addons: t.List[_addons.AddonsConfig] = []\n    \"\"\"\n    Odoo addons configurations\n    \"\"\"\n    dependencies: dependency.DependenciesConfig = dependency.DependenciesConfig()\n    \"\"\"\n    Odoo dependencies configurations\n    \"\"\"\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_vers\u00eeon(cls, v: float) -&gt; float:\n        \"\"\"\n        Validate supported Odoo version\n\n        Raises:\n            ValueError: When provided version is not supported\n\n        Returns:\n            float: Odoo version\n        \"\"\"\n        if v not in (11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0):\n            raise ValueError(f\"Unsuported Odoo version {v}\")\n        return v\n</code></pre>"},{"location":"reference.html#odooghost.config.OdooStackConfig.addons","title":"<code>addons: t.List[_addons.AddonsConfig] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Odoo addons configurations</p>"},{"location":"reference.html#odooghost.config.OdooStackConfig.cmdline","title":"<code>cmdline: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Odoo-bin cmdline</p>"},{"location":"reference.html#odooghost.config.OdooStackConfig.dependencies","title":"<code>dependencies: dependency.DependenciesConfig = dependency.DependenciesConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Odoo dependencies configurations</p>"},{"location":"reference.html#odooghost.config.OdooStackConfig.version","title":"<code>version: float</code>  <code>instance-attribute</code>","text":"<p>Odoo version</p>"},{"location":"reference.html#odooghost.config.OdooStackConfig.validate_vers\u00eeon","title":"<code>validate_vers\u00eeon(v)</code>  <code>classmethod</code>","text":"<p>Validate supported Odoo version</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When provided version is not supported</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Odoo version</p> Source code in <code>odooghost/config/service.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_vers\u00eeon(cls, v: float) -&gt; float:\n    \"\"\"\n    Validate supported Odoo version\n\n    Raises:\n        ValueError: When provided version is not supported\n\n    Returns:\n        float: Odoo version\n    \"\"\"\n    if v not in (11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0):\n        raise ValueError(f\"Unsuported Odoo version {v}\")\n    return v\n</code></pre>"},{"location":"reference.html#odooghost.config.PostgresStackConfig","title":"<code>PostgresStackConfig</code>","text":"<p>             Bases: <code>StackServiceConfig</code></p> <p>Postgres stack configuration holds database configuration It support both remote and local databse</p> Source code in <code>odooghost/config/service.py</code> <pre><code>class PostgresStackConfig(StackServiceConfig):\n    \"\"\"\n    Postgres stack configuration holds database configuration\n    It support both remote and local databse\n    \"\"\"\n\n    type: t.Literal[\"local\", \"remote\"]\n    \"\"\"\n    Type of database config\n    \"\"\"\n    version: int\n    \"\"\"\n    Database version\n    \"\"\"\n    host: t.Optional[str] = None\n    \"\"\"\n    Database hostname\n    \"\"\"\n    user: t.Optional[str] = None\n    \"\"\"\n    Database user\n    \"\"\"\n    db: t.Optional[str] = \"postgres\"\n    \"\"\"\n    Database template (only availible in local type)\n    \"\"\"\n    password: t.Optional[str] = None\n    \"\"\"\n    Database user password\n    \"\"\"\n</code></pre>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.db","title":"<code>db: t.Optional[str] = 'postgres'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database template (only availible in local type)</p>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.host","title":"<code>host: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database hostname</p>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.password","title":"<code>password: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database user password</p>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.type","title":"<code>type: t.Literal['local', 'remote']</code>  <code>instance-attribute</code>","text":"<p>Type of database config</p>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.user","title":"<code>user: t.Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database user</p>"},{"location":"reference.html#odooghost.config.PostgresStackConfig.version","title":"<code>version: int</code>  <code>instance-attribute</code>","text":"<p>Database version</p>"},{"location":"reference.html#odooghost.config.StackConfig","title":"<code>StackConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Stack configuration</p> Source code in <code>odooghost/config/stack.py</code> <pre><code>class StackConfig(BaseModel):\n    \"\"\"\n    Stack configuration\n    \"\"\"\n\n    name: str\n    \"\"\"\n    Name of stack\n    \"\"\"\n    services: service.StackServicesConfig\n    \"\"\"\n    Services of stack\n    \"\"\"\n    network: StackNetworkConfig = StackNetworkConfig()\n    \"\"\"\n    Network config\n    \"\"\"\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, v: str) -&gt; str:\n        \"\"\"\n        Validate stack name\n\n        Args:\n            v (str): Stack name\n\n        Raises:\n            ValueError: When stack name is not valid\n\n        Returns:\n            str: Stack name\n        \"\"\"\n        if \" \" in v or not re.match(r\"^[\\w-]+$\", v):\n            raise ValueError(\"Stack name must not contain spaces or special characters\")\n        return v\n\n    @classmethod\n    def from_file(cls, file_path: Path) -&gt; \"StackConfig\":\n        \"\"\"\n        Return a StackConfig instance from JSON/YAML file config\n\n        Args:\n            file_path (Path): file path\n\n        Raises:\n            RuntimeError: when the file does not exists\n\n        Returns:\n            StackConfig: StackConfig instance\n        \"\"\"\n        if not file_path.exists():\n            # TODO replace this error\n            raise RuntimeError(\"File does not exist\")\n        data = {}\n        with open(file_path.as_posix(), \"r\") as stream:\n            if file_path.name.endswith(\".json\"):\n                data = json.load(fp=stream)\n            elif file_path.name.endswith(\".yml\") or file_path.name.endswith(\".yaml\"):\n                data = yaml.safe_load(stream=stream)\n            else:\n                raise exceptions.StackConfigError(\"Unsupported file format\")\n        return cls(**data)\n\n    def get_service_hostname(self, service: str) -&gt; str:\n        \"\"\"\n        Get given service name regatding netowrk.\n        We do prefix the service name with the stack name\n        if the stack network is shared with other.\n        This is done to allow running multiple stack's at\n        the same time with the same network\n\n        Args:\n            service (str): service name\n\n        Returns:\n            str: name of the given service\n        \"\"\"\n        return (\n            f\"{self.name.lower()}-{service}\"\n            if self.network.mode == \"shared\"\n            else service\n        )\n\n    def get_network_name(self) -&gt; str:\n        \"\"\"\n        Get netowkr name regarding network mode\n        T\n\n        Returns:\n            str: Stack netowrk name\n        \"\"\"\n        return constant.COMMON_NETWORK_NAME or f\"{constant.LABEL_NAME}_{self.name}\"\n</code></pre>"},{"location":"reference.html#odooghost.config.StackConfig.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of stack</p>"},{"location":"reference.html#odooghost.config.StackConfig.network","title":"<code>network: StackNetworkConfig = StackNetworkConfig()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Network config</p>"},{"location":"reference.html#odooghost.config.StackConfig.services","title":"<code>services: service.StackServicesConfig</code>  <code>instance-attribute</code>","text":"<p>Services of stack</p>"},{"location":"reference.html#odooghost.config.StackConfig.from_file","title":"<code>from_file(file_path)</code>  <code>classmethod</code>","text":"<p>Return a StackConfig instance from JSON/YAML file config</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>file path</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>when the file does not exists</p> <p>Returns:</p> Name Type Description <code>StackConfig</code> <code>StackConfig</code> <p>StackConfig instance</p> Source code in <code>odooghost/config/stack.py</code> <pre><code>@classmethod\ndef from_file(cls, file_path: Path) -&gt; \"StackConfig\":\n    \"\"\"\n    Return a StackConfig instance from JSON/YAML file config\n\n    Args:\n        file_path (Path): file path\n\n    Raises:\n        RuntimeError: when the file does not exists\n\n    Returns:\n        StackConfig: StackConfig instance\n    \"\"\"\n    if not file_path.exists():\n        # TODO replace this error\n        raise RuntimeError(\"File does not exist\")\n    data = {}\n    with open(file_path.as_posix(), \"r\") as stream:\n        if file_path.name.endswith(\".json\"):\n            data = json.load(fp=stream)\n        elif file_path.name.endswith(\".yml\") or file_path.name.endswith(\".yaml\"):\n            data = yaml.safe_load(stream=stream)\n        else:\n            raise exceptions.StackConfigError(\"Unsupported file format\")\n    return cls(**data)\n</code></pre>"},{"location":"reference.html#odooghost.config.StackConfig.get_network_name","title":"<code>get_network_name()</code>","text":"<p>Get netowkr name regarding network mode T</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Stack netowrk name</p> Source code in <code>odooghost/config/stack.py</code> <pre><code>def get_network_name(self) -&gt; str:\n    \"\"\"\n    Get netowkr name regarding network mode\n    T\n\n    Returns:\n        str: Stack netowrk name\n    \"\"\"\n    return constant.COMMON_NETWORK_NAME or f\"{constant.LABEL_NAME}_{self.name}\"\n</code></pre>"},{"location":"reference.html#odooghost.config.StackConfig.get_service_hostname","title":"<code>get_service_hostname(service)</code>","text":"<p>Get given service name regatding netowrk. We do prefix the service name with the stack name if the stack network is shared with other. This is done to allow running multiple stack's at the same time with the same network</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>service name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>name of the given service</p> Source code in <code>odooghost/config/stack.py</code> <pre><code>def get_service_hostname(self, service: str) -&gt; str:\n    \"\"\"\n    Get given service name regatding netowrk.\n    We do prefix the service name with the stack name\n    if the stack network is shared with other.\n    This is done to allow running multiple stack's at\n    the same time with the same network\n\n    Args:\n        service (str): service name\n\n    Returns:\n        str: name of the given service\n    \"\"\"\n    return (\n        f\"{self.name.lower()}-{service}\"\n        if self.network.mode == \"shared\"\n        else service\n    )\n</code></pre>"},{"location":"reference.html#odooghost.config.StackConfig.validate_name","title":"<code>validate_name(v)</code>  <code>classmethod</code>","text":"<p>Validate stack name</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Stack name</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>When stack name is not valid</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Stack name</p> Source code in <code>odooghost/config/stack.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, v: str) -&gt; str:\n    \"\"\"\n    Validate stack name\n\n    Args:\n        v (str): Stack name\n\n    Raises:\n        ValueError: When stack name is not valid\n\n    Returns:\n        str: Stack name\n    \"\"\"\n    if \" \" in v or not re.match(r\"^[\\w-]+$\", v):\n        raise ValueError(\"Stack name must not contain spaces or special characters\")\n    return v\n</code></pre>"},{"location":"reference.html#odooghost.config.StackServiceConfig","title":"<code>StackServiceConfig</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract config for stack services</p> Source code in <code>odooghost/config/service.py</code> <pre><code>class StackServiceConfig(BaseModel, abc.ABC):\n    \"\"\"\n    Abstract config for stack services\n    \"\"\"\n\n    service_port: t.Optional[int] = None\n    \"\"\"\n    Map local port to container sercice port\n    \"\"\"\n</code></pre>"},{"location":"reference.html#odooghost.config.StackServiceConfig.service_port","title":"<code>service_port: t.Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Map local port to container sercice port</p>"},{"location":"reference.html#odooghost.stack","title":"<code>odooghost.stack</code>","text":""},{"location":"reference.html#odooghost.stack.Stack","title":"<code>Stack</code>","text":"<p>Stack manage differents Odoo stacks regarding it's config</p> Source code in <code>odooghost/stack.py</code> <pre><code>class Stack:\n    \"\"\"\n    Stack manage differents Odoo stacks regarding it's config\n    \"\"\"\n\n    def __init__(self, config: \"config.StackConfig\") -&gt; None:\n        self._config = config\n        self._services: t.Dict[str, t.Type[\"BaseService\"]] = dict(\n            db=db.DbService(stack_config=config),\n            odoo=odoo.OdooService(stack_config=config),\n        )\n        if config.services.mail:\n            self._services.update(dict(mail=mail.MailService(stack_config=config)))\n\n    def _check_state(self) -&gt; StackState:\n        \"\"\"\n        Check Stack state\n\n        Returns:\n            StackState: return current state\n        \"\"\"\n        if self.name not in ctx.stacks:\n            return StackState.NONE\n        # TODO implement partial state\n        return StackState.READY\n\n    def _ensure_exists(func: t.Callable) -&gt; t.Callable:\n        \"\"\"\n        Ensure Stack exists\n\n        Args:\n            func (t.Callable): function to call\n\n        Raises:\n            StackNotFoundError: When Stack does not exists\n\n        Returns:\n            t.Callable: wrapped function\n        \"\"\"\n\n        @wraps(func)\n        def inner(self: \"Stack\", *args, **kwargs) -&gt; t.Any:\n            if not self.exists:\n                raise StackNotFoundError(f\"Stack {self.name} does not exists !\")\n            return func(self, *args, **kwargs)\n\n        return inner\n\n    @classmethod\n    def from_file(cls, file_path: Path) -&gt; \"Stack\":\n        \"\"\"\n        Instanciate Stack from file\n\n        File could be both YAML and JSON\n\n        Args:\n            file_path (Path): stack config file path\n\n        Returns:\n            Stack: Stack instance\n        \"\"\"\n        return cls(config=config.StackConfig.from_file(file_path=file_path))\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; \"Stack\":\n        \"\"\"\n        Instanciate Stack from name\n        Stack config will be searched from Context\n\n        Args:\n            name (str): Stack name\n\n        Returns:\n            Stack: Stack instance\n        \"\"\"\n        return cls(config=ctx.stacks.get(stack_name=name))\n\n    @classmethod\n    def count(cls) -&gt; int:\n        \"\"\"\n        Count all stacks in context\n\n        Returns:\n            int: stack count\n        \"\"\"\n        return len(ctx.stacks)\n\n    @classmethod\n    def list(cls, running: bool = False) -&gt; t.Generator[\"Stack\", None, None]:\n        \"\"\"\n        List all stacks\n\n        Yields:\n            Srack: Stack instance\n        \"\"\"\n        # TODO implment running stack only\n        if running:\n            for stack_name in set(\n                map(\n                    lambda container: container.stack,\n                    Container.search(\n                        filters={\n                            \"label\": labels_as_list(\n                                {\n                                    constant.LABEL_NAME: \"true\",\n                                }\n                            )\n                        }\n                    ),\n                )\n            ):\n                yield cls.from_name(name=stack_name)\n\n        else:\n            for stack_config in ctx.stacks:\n                yield cls(config=stack_config)\n\n    def labels(self, one_off: OneOffFilter = OneOffFilter.exclude) -&gt; Labels:\n        \"\"\"\n        Get Stack labels\n\n        Returns:\n            Labels: Labels as dict\n        \"\"\"\n        labels = {\n            constant.LABEL_NAME: \"true\",\n            constant.LABEL_STACKNAME: self.name,\n        }\n        OneOffFilter.update_labels(value=one_off, labels=labels)\n        return labels\n\n    def services(self) -&gt; t.List[t.Type[\"BaseService\"]]:\n        return list(self._services.values())\n\n    def get_service(self, name: str) -&gt; t.Type[\"BaseService\"]:\n        try:\n            service = self._services[name]\n        except KeyError:\n            # TODO make exception\n            raise Exception\n        return service\n\n    def containers(\n        self,\n        filters: t.Optional[Filters] = None,\n        labels: t.Optional[Labels] = None,\n        stopped: bool = False,\n        one_off: OneOffFilter = OneOffFilter.exclude,\n    ) -&gt; t.List[Container]:\n        \"\"\"\n        Get Stack containers\n\n        Args:\n            filters (t.Optional[Filters], optional): Search filters. Defaults to None.\n            labels (t.Optional[Labels], optional): Additionnal search labels. Defaults to None.\n            stopped (bool, optional): Get stopped containers. Defaults to False.\n\n        Returns:\n            t.List[Container]: Container list\n        \"\"\"\n        if filters is None:\n            filters = {}\n        filters.update(\n            {\n                \"label\": labels_as_list(self.labels(one_off=one_off))\n                + (labels_as_list(labels) if labels else [])\n            }\n        )\n        return Container.search(filters=filters, stopped=stopped)\n\n    def create(\n        self, force: bool = False, do_pull: bool = True, ensure_addons: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Create Stack\n\n        Args:\n            force (bool, optional): Force recreate of dangling containers. Defaults to False.\n            do_pull (bool, optional): Pull base images. Defaults to True.\n            ensure_addons (bool, optional): Ensure Odoo addons. Defaults to True.\n\n        Raises:\n            StackAlreadyExistsError: When Stack alreary exists\n        \"\"\"\n        if self.exists:\n            raise StackAlreadyExistsError(f\"Stack {self.name} already exists !\")\n        logger.info(f\"Creating Stack {self.name} ...\")\n        # TODO allow custom network\n        ctx.ensure_common_network()\n        for service in self.services():\n            service.create(force=force, do_pull=do_pull, ensure_addons=ensure_addons)\n\n        ctx.stacks.create(config=self._config)\n        logger.info(f\"Created Stack {self.name} !\")\n\n    @_ensure_exists\n    def drop(self, volumes: bool = False) -&gt; None:\n        \"\"\"\n        Drop Stack\n\n        Args:\n            volumes (bool, optional): Drop volumes. Defaults to False.\n\n        Raises:\n            StackNotFoundError: When Stack does not exists\n        \"\"\"\n        logger.info(f\"Dropping Stack {self.name} ...\")\n        for service in self.services():\n            service.drop(volumes=volumes)\n        ctx.stacks.drop(stack_name=self.name)\n        logger.info(f\"Dropped Stack {self.name} !\")\n\n    @_ensure_exists\n    def pull(self) -&gt; None:\n        \"\"\"\n        Pull Stack\n        \"\"\"\n        logger.info(f\"Pulling Stack {self.name} ...\")\n        for service in self.services():\n            service.pull()\n        logger.info(f\"Pulled Stack {self.name} !\")\n\n    @_ensure_exists\n    def update(self, do_pull: bool = False) -&gt; None:\n        \"\"\"\n        Update Stack\n        \"\"\"\n        logger.info(f\"Updating Stack {self.name} ...\")\n        for service in self.services():\n            if do_pull:\n                service.pull()\n            service.update()\n        ctx.stacks.update(config=self._config)\n        logger.info(f\"Updated Stack {self.name} !\")\n\n    @_ensure_exists\n    def start(self) -&gt; None:\n        \"\"\"\n        Start Stack\n\n        Raises:\n            StackNotFoundError: When Stack does not exists\n        \"\"\"\n        containers = self.containers(stopped=True)\n        if not len(containers):\n            logger.warning(\"No container to start !\")\n            return\n        for container in containers:\n            logger.info(f\"Starting container {container.name}\")\n            container.start()\n\n    @_ensure_exists\n    def stop(self, timeout: int = 10, wait: bool = False) -&gt; None:\n        \"\"\"\n        Stop Stack\n\n        Args:\n            timeout (int, optional): timeout before sending SIGKILL. Defaults to 10.\n\n        Raises:\n            StackNotFoundError: When stack does not exists\n        \"\"\"\n        containers = self.containers()\n        if not len(containers):\n            logger.warning(\"No container to stop !\")\n            return\n        for container in containers:\n            logger.info(f\"Stopping container {container.name}\")\n            container.stop(timeout=timeout)\n        if wait:\n            logger.info(\"Waiting for containers to stop\")\n            for container in containers:\n                container.wait()\n\n    @_ensure_exists\n    def restart(self, timeout: int = 10) -&gt; None:\n        \"\"\"\n        Restart Stack\n\n        Args:\n            timeout (int, optional): timeout before sending SIGKILL. Defaults to 10.\n\n        Raises:\n            StackNotFoundError: When stack does not exists\n        \"\"\"\n        containers = self.containers()\n        if not len(containers):\n            logger.warning(\"No container to restart !\")\n            return\n        for container in containers:\n            logger.info(f\"Restarting container {container.name}\")\n            container.restart(timeout=timeout)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Return name of stack\n\n        Returns:\n            str: Stack name\n        \"\"\"\n        return self._config.name\n\n    @property\n    def state(self) -&gt; StackState:\n        \"\"\"\n        Check state and return it\n\n        Returns:\n            StackState: Current Stack state\n        \"\"\"\n        return self._check_state()\n\n    @property\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Check if stack already exists\n\n        Returns:\n            bool\n        \"\"\"\n        return self.state != StackState.NONE\n\n    @property\n    def id(self) -&gt; str:\n        return get_hash(self.name)\n\n    def __repr__(self):\n        \"\"\"\n        Stack repr\n        \"\"\"\n        return f\"&lt;Stack: {self.name}&gt;\"\n\n    def __eq__(self, other: \"Stack\") -&gt; bool:\n        \"\"\"\n        Check if Stack equal other Stack\n\n        Args:\n            other (Stack): Other Stack instance\n\n        Returns:\n            bool:\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.name == other.name\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.exists","title":"<code>exists: bool</code>  <code>property</code>","text":"<p>Check if stack already exists</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool</p>"},{"location":"reference.html#odooghost.stack.Stack.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Return name of stack</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Stack name</p>"},{"location":"reference.html#odooghost.stack.Stack.state","title":"<code>state: StackState</code>  <code>property</code>","text":"<p>Check state and return it</p> <p>Returns:</p> Name Type Description <code>StackState</code> <code>StackState</code> <p>Current Stack state</p>"},{"location":"reference.html#odooghost.stack.Stack.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if Stack equal other Stack</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Stack</code> <p>Other Stack instance</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> Source code in <code>odooghost/stack.py</code> <pre><code>def __eq__(self, other: \"Stack\") -&gt; bool:\n    \"\"\"\n    Check if Stack equal other Stack\n\n    Args:\n        other (Stack): Other Stack instance\n\n    Returns:\n        bool:\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    return self.name == other.name\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.__repr__","title":"<code>__repr__()</code>","text":"<p>Stack repr</p> Source code in <code>odooghost/stack.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Stack repr\n    \"\"\"\n    return f\"&lt;Stack: {self.name}&gt;\"\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.containers","title":"<code>containers(filters=None, labels=None, stopped=False, one_off=OneOffFilter.exclude)</code>","text":"<p>Get Stack containers</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Optional[Filters]</code> <p>Search filters. Defaults to None.</p> <code>None</code> <code>labels</code> <code>Optional[Labels]</code> <p>Additionnal search labels. Defaults to None.</p> <code>None</code> <code>stopped</code> <code>bool</code> <p>Get stopped containers. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Container]</code> <p>t.List[Container]: Container list</p> Source code in <code>odooghost/stack.py</code> <pre><code>def containers(\n    self,\n    filters: t.Optional[Filters] = None,\n    labels: t.Optional[Labels] = None,\n    stopped: bool = False,\n    one_off: OneOffFilter = OneOffFilter.exclude,\n) -&gt; t.List[Container]:\n    \"\"\"\n    Get Stack containers\n\n    Args:\n        filters (t.Optional[Filters], optional): Search filters. Defaults to None.\n        labels (t.Optional[Labels], optional): Additionnal search labels. Defaults to None.\n        stopped (bool, optional): Get stopped containers. Defaults to False.\n\n    Returns:\n        t.List[Container]: Container list\n    \"\"\"\n    if filters is None:\n        filters = {}\n    filters.update(\n        {\n            \"label\": labels_as_list(self.labels(one_off=one_off))\n            + (labels_as_list(labels) if labels else [])\n        }\n    )\n    return Container.search(filters=filters, stopped=stopped)\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.count","title":"<code>count()</code>  <code>classmethod</code>","text":"<p>Count all stacks in context</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>stack count</p> Source code in <code>odooghost/stack.py</code> <pre><code>@classmethod\ndef count(cls) -&gt; int:\n    \"\"\"\n    Count all stacks in context\n\n    Returns:\n        int: stack count\n    \"\"\"\n    return len(ctx.stacks)\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.create","title":"<code>create(force=False, do_pull=True, ensure_addons=True)</code>","text":"<p>Create Stack</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Force recreate of dangling containers. Defaults to False.</p> <code>False</code> <code>do_pull</code> <code>bool</code> <p>Pull base images. Defaults to True.</p> <code>True</code> <code>ensure_addons</code> <code>bool</code> <p>Ensure Odoo addons. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>StackAlreadyExistsError</code> <p>When Stack alreary exists</p> Source code in <code>odooghost/stack.py</code> <pre><code>def create(\n    self, force: bool = False, do_pull: bool = True, ensure_addons: bool = True\n) -&gt; None:\n    \"\"\"\n    Create Stack\n\n    Args:\n        force (bool, optional): Force recreate of dangling containers. Defaults to False.\n        do_pull (bool, optional): Pull base images. Defaults to True.\n        ensure_addons (bool, optional): Ensure Odoo addons. Defaults to True.\n\n    Raises:\n        StackAlreadyExistsError: When Stack alreary exists\n    \"\"\"\n    if self.exists:\n        raise StackAlreadyExistsError(f\"Stack {self.name} already exists !\")\n    logger.info(f\"Creating Stack {self.name} ...\")\n    # TODO allow custom network\n    ctx.ensure_common_network()\n    for service in self.services():\n        service.create(force=force, do_pull=do_pull, ensure_addons=ensure_addons)\n\n    ctx.stacks.create(config=self._config)\n    logger.info(f\"Created Stack {self.name} !\")\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.drop","title":"<code>drop(volumes=False)</code>","text":"<p>Drop Stack</p> <p>Parameters:</p> Name Type Description Default <code>volumes</code> <code>bool</code> <p>Drop volumes. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>StackNotFoundError</code> <p>When Stack does not exists</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef drop(self, volumes: bool = False) -&gt; None:\n    \"\"\"\n    Drop Stack\n\n    Args:\n        volumes (bool, optional): Drop volumes. Defaults to False.\n\n    Raises:\n        StackNotFoundError: When Stack does not exists\n    \"\"\"\n    logger.info(f\"Dropping Stack {self.name} ...\")\n    for service in self.services():\n        service.drop(volumes=volumes)\n    ctx.stacks.drop(stack_name=self.name)\n    logger.info(f\"Dropped Stack {self.name} !\")\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.from_file","title":"<code>from_file(file_path)</code>  <code>classmethod</code>","text":"<p>Instanciate Stack from file</p> <p>File could be both YAML and JSON</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>stack config file path</p> required <p>Returns:</p> Name Type Description <code>Stack</code> <code>Stack</code> <p>Stack instance</p> Source code in <code>odooghost/stack.py</code> <pre><code>@classmethod\ndef from_file(cls, file_path: Path) -&gt; \"Stack\":\n    \"\"\"\n    Instanciate Stack from file\n\n    File could be both YAML and JSON\n\n    Args:\n        file_path (Path): stack config file path\n\n    Returns:\n        Stack: Stack instance\n    \"\"\"\n    return cls(config=config.StackConfig.from_file(file_path=file_path))\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.from_name","title":"<code>from_name(name)</code>  <code>classmethod</code>","text":"<p>Instanciate Stack from name Stack config will be searched from Context</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Stack name</p> required <p>Returns:</p> Name Type Description <code>Stack</code> <code>Stack</code> <p>Stack instance</p> Source code in <code>odooghost/stack.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str) -&gt; \"Stack\":\n    \"\"\"\n    Instanciate Stack from name\n    Stack config will be searched from Context\n\n    Args:\n        name (str): Stack name\n\n    Returns:\n        Stack: Stack instance\n    \"\"\"\n    return cls(config=ctx.stacks.get(stack_name=name))\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.labels","title":"<code>labels(one_off=OneOffFilter.exclude)</code>","text":"<p>Get Stack labels</p> <p>Returns:</p> Name Type Description <code>Labels</code> <code>Labels</code> <p>Labels as dict</p> Source code in <code>odooghost/stack.py</code> <pre><code>def labels(self, one_off: OneOffFilter = OneOffFilter.exclude) -&gt; Labels:\n    \"\"\"\n    Get Stack labels\n\n    Returns:\n        Labels: Labels as dict\n    \"\"\"\n    labels = {\n        constant.LABEL_NAME: \"true\",\n        constant.LABEL_STACKNAME: self.name,\n    }\n    OneOffFilter.update_labels(value=one_off, labels=labels)\n    return labels\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.list","title":"<code>list(running=False)</code>  <code>classmethod</code>","text":"<p>List all stacks</p> <p>Yields:</p> Name Type Description <code>Srack</code> <code>Stack</code> <p>Stack instance</p> Source code in <code>odooghost/stack.py</code> <pre><code>@classmethod\ndef list(cls, running: bool = False) -&gt; t.Generator[\"Stack\", None, None]:\n    \"\"\"\n    List all stacks\n\n    Yields:\n        Srack: Stack instance\n    \"\"\"\n    # TODO implment running stack only\n    if running:\n        for stack_name in set(\n            map(\n                lambda container: container.stack,\n                Container.search(\n                    filters={\n                        \"label\": labels_as_list(\n                            {\n                                constant.LABEL_NAME: \"true\",\n                            }\n                        )\n                    }\n                ),\n            )\n        ):\n            yield cls.from_name(name=stack_name)\n\n    else:\n        for stack_config in ctx.stacks:\n            yield cls(config=stack_config)\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.pull","title":"<code>pull()</code>","text":"<p>Pull Stack</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef pull(self) -&gt; None:\n    \"\"\"\n    Pull Stack\n    \"\"\"\n    logger.info(f\"Pulling Stack {self.name} ...\")\n    for service in self.services():\n        service.pull()\n    logger.info(f\"Pulled Stack {self.name} !\")\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.restart","title":"<code>restart(timeout=10)</code>","text":"<p>Restart Stack</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>timeout before sending SIGKILL. Defaults to 10.</p> <code>10</code> <p>Raises:</p> Type Description <code>StackNotFoundError</code> <p>When stack does not exists</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef restart(self, timeout: int = 10) -&gt; None:\n    \"\"\"\n    Restart Stack\n\n    Args:\n        timeout (int, optional): timeout before sending SIGKILL. Defaults to 10.\n\n    Raises:\n        StackNotFoundError: When stack does not exists\n    \"\"\"\n    containers = self.containers()\n    if not len(containers):\n        logger.warning(\"No container to restart !\")\n        return\n    for container in containers:\n        logger.info(f\"Restarting container {container.name}\")\n        container.restart(timeout=timeout)\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.start","title":"<code>start()</code>","text":"<p>Start Stack</p> <p>Raises:</p> Type Description <code>StackNotFoundError</code> <p>When Stack does not exists</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef start(self) -&gt; None:\n    \"\"\"\n    Start Stack\n\n    Raises:\n        StackNotFoundError: When Stack does not exists\n    \"\"\"\n    containers = self.containers(stopped=True)\n    if not len(containers):\n        logger.warning(\"No container to start !\")\n        return\n    for container in containers:\n        logger.info(f\"Starting container {container.name}\")\n        container.start()\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.stop","title":"<code>stop(timeout=10, wait=False)</code>","text":"<p>Stop Stack</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>timeout before sending SIGKILL. Defaults to 10.</p> <code>10</code> <p>Raises:</p> Type Description <code>StackNotFoundError</code> <p>When stack does not exists</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef stop(self, timeout: int = 10, wait: bool = False) -&gt; None:\n    \"\"\"\n    Stop Stack\n\n    Args:\n        timeout (int, optional): timeout before sending SIGKILL. Defaults to 10.\n\n    Raises:\n        StackNotFoundError: When stack does not exists\n    \"\"\"\n    containers = self.containers()\n    if not len(containers):\n        logger.warning(\"No container to stop !\")\n        return\n    for container in containers:\n        logger.info(f\"Stopping container {container.name}\")\n        container.stop(timeout=timeout)\n    if wait:\n        logger.info(\"Waiting for containers to stop\")\n        for container in containers:\n            container.wait()\n</code></pre>"},{"location":"reference.html#odooghost.stack.Stack.update","title":"<code>update(do_pull=False)</code>","text":"<p>Update Stack</p> Source code in <code>odooghost/stack.py</code> <pre><code>@_ensure_exists\ndef update(self, do_pull: bool = False) -&gt; None:\n    \"\"\"\n    Update Stack\n    \"\"\"\n    logger.info(f\"Updating Stack {self.name} ...\")\n    for service in self.services():\n        if do_pull:\n            service.pull()\n        service.update()\n    ctx.stacks.update(config=self._config)\n    logger.info(f\"Updated Stack {self.name} !\")\n</code></pre>"},{"location":"reference.html#odooghost.stack.StackState","title":"<code>StackState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>StackState obviously holds StackState</p> Source code in <code>odooghost/stack.py</code> <pre><code>class StackState(enum.Enum):\n    \"\"\"\n    StackState obviously holds StackState\n    \"\"\"\n\n    NONE: int = 0\n    PARTIAL: int = 1\n    READY: int = 2\n</code></pre>"},{"location":"reference.html#odooghost.services","title":"<code>odooghost.services</code>","text":""},{"location":"reference.html#odooghost.context","title":"<code>odooghost.context</code>","text":""},{"location":"reference.html#odooghost.context.Context","title":"<code>Context</code>","text":"<p>Context holds contextual data for OdooGhost</p> Source code in <code>odooghost/context.py</code> <pre><code>class Context:\n    \"\"\"\n    Context holds contextual data for OdooGhost\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._app_dir = constant.APP_DIR\n        self._config_path = self._app_dir / \"config.yml\"\n        self._stack_ctx = StackContext(self._app_dir / \"stacks\")\n        self._data_dir = self._app_dir / \"data\"\n        self._plugins_dir = self._app_dir / \"plugins\"\n        self._config: t.Optional[ContextConfig] = None\n        self._docker_client: t.Optional[docker.DockerClient] = None\n        self._init = False\n        self.initialize()\n\n    def check_setup_state(self) -&gt; bool:\n        \"\"\"\n        Check setup status\n\n        Returns:\n            bool\n        \"\"\"\n        return self._app_dir.exists()\n\n    def initialize(self) -&gt; None:\n        \"\"\"\n        Initialize context\n        \"\"\"\n        if self.check_setup_state():\n            with open(self._config_path.as_posix(), \"r\") as stream:\n                self._config = ContextConfig(**yaml.safe_load(stream=stream))\n            self._init = True\n\n    def setup(self, version: str, working_dir: Path) -&gt; None:\n        \"\"\"\n        Setup OdooGhost\n\n        Args:\n            version (str): OdooGhost version\n            working_dir (Path): working directory\n\n        Raises:\n            exceptions.ContextAlreadySetupError: Already setup\n        \"\"\"\n        if self.check_setup_state():\n            raise exceptions.ContextAlreadySetupError(\"App already setup !\")\n\n        # TODO handle OSError\n        for _dir in (\n            self._app_dir,\n            self._stack_ctx._working_dir,\n            self._data_dir,\n            self._plugins_dir,\n        ):\n            _dir.mkdir()\n        config_data = dict(\n            version=version, working_dir=working_dir.resolve().as_posix()\n        )\n        with open(self._config_path.as_posix(), \"w\") as stream:\n            yaml.safe_dump(config_data, stream=stream)\n\n        self.initialize()\n\n    def create_common_network(self) -&gt; None:\n        \"\"\"\n        Create common Docker network for stacks\n\n        Raises:\n            exceptions.CommonNetworkEnsureError: When create fail\n        \"\"\"\n        try:\n            self.docker.networks.create(\n                name=constant.COMMON_NETWORK_NAME,\n                driver=\"bridge\",\n                check_duplicate=True,\n                attachable=True,\n                scope=\"local\",\n            )\n        except APIError:\n            raise exceptions.CommonNetworkEnsureError(\"Failed to create common network\")\n\n    def ensure_common_network(self) -&gt; None:\n        \"\"\"\n        Ensure common Docker network\n\n        Raises:\n            exceptions.CommonNetworkEnsureError: When ensure fail\n        \"\"\"\n        try:\n            self.docker.networks.get(constant.COMMON_NETWORK_NAME)\n        except NotFound:\n            self.create_common_network()\n        except APIError:\n            raise exceptions.CommonNetworkEnsureError(\"Failed to ensure common network\")\n\n    def get_build_context_path(self) -&gt; Path:\n        \"\"\"\n        Get build context path\n\n        Returns:\n            Path: Path to build context\n        \"\"\"\n        return Path(\"/tmp/odooghost\")  # nosec B108\n\n    @property\n    def docker(self) -&gt; \"docker.DockerClient\":\n        \"\"\"\n        Lazyily return Docker client\n\n        Returns:\n            docker.DockerClient: Docker client instance\n        \"\"\"\n        if not self._docker_client:\n            self._docker_client = docker.from_env()\n        return self._docker_client\n\n    @property\n    def config(self) -&gt; ContextConfig:\n        \"\"\"\n        Get context config\n\n        Raises:\n            RuntimeError: when context was not initialized\n\n        Returns:\n            ContextConfig: context config\n        \"\"\"\n        if not self._init:\n            raise RuntimeError(\"Can not get config before initialize has been done\")\n        return self._config\n\n    @property\n    def stacks(self) -&gt; StackContext:\n        if not self._init:\n            raise RuntimeError(\n                \"Can not get stack config manager before initialize has been done\"\n            )\n        return self._stack_ctx\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.config","title":"<code>config: ContextConfig</code>  <code>property</code>","text":"<p>Get context config</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>when context was not initialized</p> <p>Returns:</p> Name Type Description <code>ContextConfig</code> <code>ContextConfig</code> <p>context config</p>"},{"location":"reference.html#odooghost.context.Context.docker","title":"<code>docker: docker.DockerClient</code>  <code>property</code>","text":"<p>Lazyily return Docker client</p> <p>Returns:</p> Type Description <code>DockerClient</code> <p>docker.DockerClient: Docker client instance</p>"},{"location":"reference.html#odooghost.context.Context.check_setup_state","title":"<code>check_setup_state()</code>","text":"<p>Check setup status</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>odooghost/context.py</code> <pre><code>def check_setup_state(self) -&gt; bool:\n    \"\"\"\n    Check setup status\n\n    Returns:\n        bool\n    \"\"\"\n    return self._app_dir.exists()\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.create_common_network","title":"<code>create_common_network()</code>","text":"<p>Create common Docker network for stacks</p> <p>Raises:</p> Type Description <code>CommonNetworkEnsureError</code> <p>When create fail</p> Source code in <code>odooghost/context.py</code> <pre><code>def create_common_network(self) -&gt; None:\n    \"\"\"\n    Create common Docker network for stacks\n\n    Raises:\n        exceptions.CommonNetworkEnsureError: When create fail\n    \"\"\"\n    try:\n        self.docker.networks.create(\n            name=constant.COMMON_NETWORK_NAME,\n            driver=\"bridge\",\n            check_duplicate=True,\n            attachable=True,\n            scope=\"local\",\n        )\n    except APIError:\n        raise exceptions.CommonNetworkEnsureError(\"Failed to create common network\")\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.ensure_common_network","title":"<code>ensure_common_network()</code>","text":"<p>Ensure common Docker network</p> <p>Raises:</p> Type Description <code>CommonNetworkEnsureError</code> <p>When ensure fail</p> Source code in <code>odooghost/context.py</code> <pre><code>def ensure_common_network(self) -&gt; None:\n    \"\"\"\n    Ensure common Docker network\n\n    Raises:\n        exceptions.CommonNetworkEnsureError: When ensure fail\n    \"\"\"\n    try:\n        self.docker.networks.get(constant.COMMON_NETWORK_NAME)\n    except NotFound:\n        self.create_common_network()\n    except APIError:\n        raise exceptions.CommonNetworkEnsureError(\"Failed to ensure common network\")\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.get_build_context_path","title":"<code>get_build_context_path()</code>","text":"<p>Get build context path</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to build context</p> Source code in <code>odooghost/context.py</code> <pre><code>def get_build_context_path(self) -&gt; Path:\n    \"\"\"\n    Get build context path\n\n    Returns:\n        Path: Path to build context\n    \"\"\"\n    return Path(\"/tmp/odooghost\")  # nosec B108\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.initialize","title":"<code>initialize()</code>","text":"<p>Initialize context</p> Source code in <code>odooghost/context.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize context\n    \"\"\"\n    if self.check_setup_state():\n        with open(self._config_path.as_posix(), \"r\") as stream:\n            self._config = ContextConfig(**yaml.safe_load(stream=stream))\n        self._init = True\n</code></pre>"},{"location":"reference.html#odooghost.context.Context.setup","title":"<code>setup(version, working_dir)</code>","text":"<p>Setup OdooGhost</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>OdooGhost version</p> required <code>working_dir</code> <code>Path</code> <p>working directory</p> required <p>Raises:</p> Type Description <code>ContextAlreadySetupError</code> <p>Already setup</p> Source code in <code>odooghost/context.py</code> <pre><code>def setup(self, version: str, working_dir: Path) -&gt; None:\n    \"\"\"\n    Setup OdooGhost\n\n    Args:\n        version (str): OdooGhost version\n        working_dir (Path): working directory\n\n    Raises:\n        exceptions.ContextAlreadySetupError: Already setup\n    \"\"\"\n    if self.check_setup_state():\n        raise exceptions.ContextAlreadySetupError(\"App already setup !\")\n\n    # TODO handle OSError\n    for _dir in (\n        self._app_dir,\n        self._stack_ctx._working_dir,\n        self._data_dir,\n        self._plugins_dir,\n    ):\n        _dir.mkdir()\n    config_data = dict(\n        version=version, working_dir=working_dir.resolve().as_posix()\n    )\n    with open(self._config_path.as_posix(), \"w\") as stream:\n        yaml.safe_dump(config_data, stream=stream)\n\n    self.initialize()\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext","title":"<code>StackContext</code>","text":"Source code in <code>odooghost/context.py</code> <pre><code>class StackContext:\n    def __init__(self, working_dir: Path) -&gt; None:\n        self._working_dir = working_dir\n\n    def _write(self, config: StackConfig) -&gt; None:\n        with open(self.get_path(config.name), \"w\") as stream:\n            json.dump(config.model_dump(), stream)\n\n    def get_path(self, stack_name: str) -&gt; Path:\n        \"\"\"\n        Get Stack config path\n\n        Args:\n            stack_name (str): name of stack\n\n        Returns:\n            Path: Stack config path\n        \"\"\"\n        return self._working_dir / f\"{stack_name}.json\"\n\n    def get(self, stack_name: str) -&gt; StackConfig:\n        \"\"\"\n        Get StackConfig\n\n        Args:\n            stack_name (str): name of stack\n\n        Returns:\n            StackConfig: Stack config instance\n        \"\"\"\n        if stack_name not in self:\n            raise exceptions.StackNotFoundError(\n                f\"Stack {stack_name} config file doest not exists\"\n            )\n        return StackConfig.from_file(file_path=self.get_path(stack_name=stack_name))\n\n    def create(self, config: StackConfig) -&gt; None:\n        \"\"\"\n        Create StackConfig file in context\n\n        Args:\n            config (StackConfig): Stack config\n\n        Raises:\n            exceptions.StackAlreadyExistsError: When stack config file exists\n        \"\"\"\n        if config in self:\n            raise exceptions.StackAlreadyExistsError(\n                f\"Stack {config.name} already exists\"\n            )\n        self._write(config=config)\n\n    def update(self, config: StackConfig) -&gt; None:\n        \"\"\"\n        Update StackConfig file in context\n\n        Args:\n            config (StackConfig): Stack config\n\n        Raises:\n            exceptions.StackNotFoundError: When stack config file does not exists\n        \"\"\"\n        if config not in self:\n            raise exceptions.StackNotFoundError(f\"Stack {config.name} not found\")\n        self._write(config=config)\n\n    def drop(self, stack_name: str) -&gt; None:\n        \"\"\"\n        Drop Stack from context\n\n        Args:\n            stack_name (str): name of stack\n        \"\"\"\n        if stack_name not in self:\n            raise exceptions.StackNotFoundError(\n                f\"Stack {stack_name} config file doest not exists\"\n            )\n        path = self.get_path(stack_name=stack_name)\n        path.unlink()\n\n    def __contains__(self, stack: str | StackConfig) -&gt; bool:\n        \"\"\"\n        Check if given stack name or StackConfig exists in context\n\n        Args:\n            stack (str | StackConfig): Stack to check\n\n        Returns:\n            bool: When stack exists or not\n        \"\"\"\n        stack_name = stack.name if isinstance(stack, StackConfig) else stack\n        stack_name = f\"{stack_name}.json\"\n        return any(stack_name == f.name for f in self._working_dir.iterdir())\n\n    def __iter__(self) -&gt; t.Iterable[StackConfig]:\n        \"\"\"\n        Iter over StackConfig's\n\n        Yields:\n            Iterator[t.Iterable[StackConfig]]: Stack config iterable\n        \"\"\"\n        for file_path in self._working_dir.iterdir():\n            yield StackConfig.from_file(file_path=file_path)\n\n    def __len__(self) -&gt; int:\n        return len(list(self._working_dir.iterdir()))\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.__contains__","title":"<code>__contains__(stack)</code>","text":"<p>Check if given stack name or StackConfig exists in context</p> <p>Parameters:</p> Name Type Description Default <code>stack</code> <code>str | StackConfig</code> <p>Stack to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>When stack exists or not</p> Source code in <code>odooghost/context.py</code> <pre><code>def __contains__(self, stack: str | StackConfig) -&gt; bool:\n    \"\"\"\n    Check if given stack name or StackConfig exists in context\n\n    Args:\n        stack (str | StackConfig): Stack to check\n\n    Returns:\n        bool: When stack exists or not\n    \"\"\"\n    stack_name = stack.name if isinstance(stack, StackConfig) else stack\n    stack_name = f\"{stack_name}.json\"\n    return any(stack_name == f.name for f in self._working_dir.iterdir())\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.__iter__","title":"<code>__iter__()</code>","text":"<p>Iter over StackConfig's</p> <p>Yields:</p> Type Description <code>Iterable[StackConfig]</code> <p>Iterator[t.Iterable[StackConfig]]: Stack config iterable</p> Source code in <code>odooghost/context.py</code> <pre><code>def __iter__(self) -&gt; t.Iterable[StackConfig]:\n    \"\"\"\n    Iter over StackConfig's\n\n    Yields:\n        Iterator[t.Iterable[StackConfig]]: Stack config iterable\n    \"\"\"\n    for file_path in self._working_dir.iterdir():\n        yield StackConfig.from_file(file_path=file_path)\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.create","title":"<code>create(config)</code>","text":"<p>Create StackConfig file in context</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>StackConfig</code> <p>Stack config</p> required <p>Raises:</p> Type Description <code>StackAlreadyExistsError</code> <p>When stack config file exists</p> Source code in <code>odooghost/context.py</code> <pre><code>def create(self, config: StackConfig) -&gt; None:\n    \"\"\"\n    Create StackConfig file in context\n\n    Args:\n        config (StackConfig): Stack config\n\n    Raises:\n        exceptions.StackAlreadyExistsError: When stack config file exists\n    \"\"\"\n    if config in self:\n        raise exceptions.StackAlreadyExistsError(\n            f\"Stack {config.name} already exists\"\n        )\n    self._write(config=config)\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.drop","title":"<code>drop(stack_name)</code>","text":"<p>Drop Stack from context</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str</code> <p>name of stack</p> required Source code in <code>odooghost/context.py</code> <pre><code>def drop(self, stack_name: str) -&gt; None:\n    \"\"\"\n    Drop Stack from context\n\n    Args:\n        stack_name (str): name of stack\n    \"\"\"\n    if stack_name not in self:\n        raise exceptions.StackNotFoundError(\n            f\"Stack {stack_name} config file doest not exists\"\n        )\n    path = self.get_path(stack_name=stack_name)\n    path.unlink()\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.get","title":"<code>get(stack_name)</code>","text":"<p>Get StackConfig</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str</code> <p>name of stack</p> required <p>Returns:</p> Name Type Description <code>StackConfig</code> <code>StackConfig</code> <p>Stack config instance</p> Source code in <code>odooghost/context.py</code> <pre><code>def get(self, stack_name: str) -&gt; StackConfig:\n    \"\"\"\n    Get StackConfig\n\n    Args:\n        stack_name (str): name of stack\n\n    Returns:\n        StackConfig: Stack config instance\n    \"\"\"\n    if stack_name not in self:\n        raise exceptions.StackNotFoundError(\n            f\"Stack {stack_name} config file doest not exists\"\n        )\n    return StackConfig.from_file(file_path=self.get_path(stack_name=stack_name))\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.get_path","title":"<code>get_path(stack_name)</code>","text":"<p>Get Stack config path</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str</code> <p>name of stack</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Stack config path</p> Source code in <code>odooghost/context.py</code> <pre><code>def get_path(self, stack_name: str) -&gt; Path:\n    \"\"\"\n    Get Stack config path\n\n    Args:\n        stack_name (str): name of stack\n\n    Returns:\n        Path: Stack config path\n    \"\"\"\n    return self._working_dir / f\"{stack_name}.json\"\n</code></pre>"},{"location":"reference.html#odooghost.context.StackContext.update","title":"<code>update(config)</code>","text":"<p>Update StackConfig file in context</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>StackConfig</code> <p>Stack config</p> required <p>Raises:</p> Type Description <code>StackNotFoundError</code> <p>When stack config file does not exists</p> Source code in <code>odooghost/context.py</code> <pre><code>def update(self, config: StackConfig) -&gt; None:\n    \"\"\"\n    Update StackConfig file in context\n\n    Args:\n        config (StackConfig): Stack config\n\n    Raises:\n        exceptions.StackNotFoundError: When stack config file does not exists\n    \"\"\"\n    if config not in self:\n        raise exceptions.StackNotFoundError(f\"Stack {config.name} not found\")\n    self._write(config=config)\n</code></pre>"},{"location":"reference.html#odooghost.renderer","title":"<code>odooghost.renderer</code>","text":""},{"location":"reference.html#odooghost.renderer.render_dockerfile","title":"<code>render_dockerfile(**kw)</code>","text":"<p>Render custom dockerfile for Odoo image</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Rendered dockerfile</p> Source code in <code>odooghost/renderer.py</code> <pre><code>def render_dockerfile(**kw) -&gt; str:\n    \"\"\"\n    Render custom dockerfile for Odoo image\n\n    Returns:\n        str: Rendered dockerfile\n    \"\"\"\n    return env.get_template(\"Dockerfile.j2\").render(**kw)\n</code></pre>"},{"location":"reference.html#odooghost.logger","title":"<code>odooghost.logger</code>","text":""},{"location":"reference.html#odooghost.logger.InterceptHandler","title":"<code>InterceptHandler</code>","text":"<p>             Bases: <code>Handler</code></p> <p>InterceptHandler convert default logging LogRecord to loguru format</p> Source code in <code>odooghost/logger.py</code> <pre><code>class InterceptHandler(logging.Handler):\n    \"\"\"\n    InterceptHandler convert default logging LogRecord to loguru format\n    \"\"\"\n\n    def emit(self, record: logging.LogRecord) -&gt; None:\n        # Get corresponding Loguru level if it exists\n        try:\n            level = logger.level(record.levelname).name\n        except ValueError:\n            level = record.levelno\n\n        # Find caller from where originated the logged message\n        frame, depth = logging.currentframe(), 2\n        while frame.f_code.co_filename == logging.__file__:\n            frame = frame.f_back\n            depth += 1\n\n        logger.opt(depth=depth, exception=record.exc_info).log(\n            level, record.getMessage()\n        )\n</code></pre>"},{"location":"reference.html#odooghost.logger.setup_cli_logging","title":"<code>setup_cli_logging()</code>","text":"<p>Setup logger for CLI</p> Source code in <code>odooghost/logger.py</code> <pre><code>def setup_cli_logging() -&gt; None:\n    \"\"\"\n    Setup logger for CLI\n    \"\"\"\n    logger.configure(\n        handlers=[\n            dict(\n                sink=sys.stderr,\n                backtrace=True,\n                diagnose=True,\n                level=\"DEBUG\",\n                format=\"&lt;level&gt;{message}&lt;/level&gt;\",\n            )\n        ]\n    )\n</code></pre>"},{"location":"tutorials.html","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p>"},{"location":"tutorials.html#managing-odoo-stacks-with-cli","title":"Managing Odoo Stacks with CLI","text":""},{"location":"tutorials.html#check-stack-configuration","title":"Check Stack Configuration","text":"<p>Command: check</p> <p>Description: Use this command to validate the configuration of one or more Stacks. Both JSON and YAML formats are supported.</p> <pre><code>$ odooghost stack check /path/to/your/config1.json /path/to/your/config2.yaml\n</code></pre>"},{"location":"tutorials.html#create-a-new-stack","title":"Create a New Stack","text":"<p>Command: create</p> <p>Description: Use this command to create one or more Stacks from given configuration files. Both JSON and YAML formats are supported.</p> <pre><code>$ odooghost stack create /path/to/your/config1.json /path/to/your/config2.yaml\n</code></pre>"},{"location":"tutorials.html#delete-a-stack","title":"Delete a Stack","text":"<p>Command: drop</p> <p>Description: Delete an existing Stack along with associated data.</p> <pre><code>$ odooghost stack drop my_odoo_stack\n</code></pre>"},{"location":"tutorials.html#start-a-stack","title":"Start a Stack","text":"<p>Command: start</p> <p>Description: Start an existing Stack.</p> <pre><code>$ odooghost stack start my_odoo_stack\n</code></pre>"},{"location":"tutorials.html#stop-a-stack","title":"Stop a Stack","text":"<p>Command: stop</p> <p>Description: Stop an existing Stack. You can specify a timeout (in seconds) before sending a SIGKILL.</p> <pre><code>$ odooghost stack stop my_odoo_stack --timeout 15\n</code></pre>"},{"location":"tutorials.html#restart-a-stack","title":"Restart a Stack","text":"<p>Command: restart</p> <p>Description: Restart an existing Stack. Similar to the \"stop\" command, you can also set a timeout.</p> <pre><code>$ odooghost stack restart my_odoo_stack --timeout 15\n</code></pre>"},{"location":"tutorials.html#list-created-stacks","title":"List Created Stacks","text":"<p>Command: ls</p> <p>Description: Display a list of all created Stacks.</p> <pre><code>$ odooghost stack ls\n</code></pre>"},{"location":"tutorials.html#list-running-stacks","title":"List Running Stacks","text":"<p>Command: ps</p> <p>Description: Display a list of all currently running Stacks.</p> <pre><code>$ odooghost stack ps\n</code></pre>"}]}